#!/usr/bin/env python
# coding: utf-8

# ### <font color='blue'>Финальный комментарий от наставника
# Большое спасибо за сообщение и фидбек.
# 
# Про леммы - да, просто хотела увидеть `print`, его до этой итерации не было. Теперь всё ок.
# 
# На самом деле ты почти всё исправил, и у тебя в итоге получилось хорошее исследование, молодец!
# Работа засчитана.

# ### <font color='green'>Комментарий для наставника
# 
# Ирина привет!
# 
# Спасибо за такие подробные классные правки. Все твои замечания постарался учесть. В следующих проектах также учту обязательно. Функцию по распределению доходов написал. Список лемм вывел, в множество перевёл. Вообще по леммам твой комментарий был непонятен написал отдельно комментарий с зелёным заголовком.
# 
# К сожалению мне по семейным обстоятельствам надо на следующей неделе максимально быстро пройти тренажёр, и максимально много сделать по проекту до следующего понедельника - 22.07.
# 
# Поэтому работу зачти. Мне надо приступить к тренажёрам уже в понедельник с 16-00 мск.
# Если дашь обратную связь, хотя бы в виде: "Ок - так пойдёт", тоже будет здорово.
# 
# С тобой шикарно работать. Иван.

# ### <font color='orange'>Комментарий от наставника 1 итерация 2
# Спасибо за исправления! Пометила тегом <span style="color:green;font-size:200%">&#10003;</span> те исправления, где всё отлично. Свои новые комментарии выделила оранжевым цветом, чтобы можно было их отличить от старых комментариев.

# ### <font color='red'>Комментарий от наставника 1
# Привет! Спасибо, что вовремя сдал задание :) Далее в файле мои комментарии ты сможешь найти в markdown с заголовком "<font color='red'><b>Комментарий от наставника</b></font>" и в комментариях в блоках с кодом после текста "НАСТАВНИК:". Пострайся учесть эти комментарии в ходе выполнения дальнейших проектов.

# ### <font color='red'>Комментарий от наставника 2 <span style="color:green;font-size:200%">&#10003;</span>
# В начале работы стоит кратко описать цели исследования и данные. Так людям, которые читают твой отчёт, будет сразу понятно, о чём дальше пойдёт речь. И тебе самому спустя время будет легче вспомнить, что тут происходило

# # Общая информация
# 
# Цель исследования установить, насколько наличие детей, семейное положение, уровень дохода и цель кредита влияют на своевременнось его погашения.
# 
# Для исследования представлена таблица, в которой построчно приведены данные о заёмщиках, и указано, были ли нарушения при возврате кредитов.

# ### <font color='red'>Комментарий от наставника 3  <span style="color:green;font-size:200%">&#10003;</span>
# Здорово, что ты нашёл неадекватности в данных и понял, как их можно поправить. Но всё же тут не хватает исследовательской части. Я понимаю, что ты смотрел на данные из которых понял, что идёт не так и что нужно исправить. Но работа аналитика похожа на исследование, и у нас принято показывать ход своих мыслей. Тебе нужно перед исправлением данных добавить код, которым ты смотришь на данные (вызывы методов `info`, `head`, `sample`, `describe` и т.п.) и изучаешь общую информацию. Затем перед каждым исправлением "показать" проблемы (например, вызывая метод `value_counts`) и пояснить, почему ты именно так решаешь эти проблемы. Думаю, что это не составит труда для тебя, ведь ты итак смотрел на данные, правда? :)

# In[132]:


import pandas as pd
data = pd.read_csv('/datasets/data.csv')
data.info()


# # Общие данные о таблице
# 
# Сначала оцениваем общую информацию о таблице. Видим 21525 значений, при этом, по столбцам days_employed, и total_income, есть только 19351 ненулевых объектов.
# 
# В таблице есть данные о детях, семейном статусе, общем доходе и цели кредита. То есть вводные данные для исследования имеются. Данные об общем доходе указаны только по 19351 из 21525 заёмщиков. Также приведены данные по числу отработанных дней, возрасту, образованию и полу. Данные по семейному статусу и статусу образования уже категорированы.

# In[58]:


print(data.head(5))
print(data.head(20))


# # Предварительная визуальная оценка проблемм с данными
# После визуальной оценки первых 20 значений в таблице, предварительные выводы следующие:
# 
# + В столбцах children, dob_days, gender, income_type, debt - данные выглядят адекватно, каких-либо корректировок не требуется.
# + В столбце days_employed указаны отрицательные значения, большие положительные значения и имеется пропуск. Количество дней указано с шестью знаками после запятой.
# 
# Необходимо проанализировать столбец данных, установить причину пропусков, причину отрицательных значений, больших положительных значений. Необходимо подумать над причиной возникновения шести знаков после запятой
# 
# + В столбце education, одно и то же слово "среднее" написано в разном регистре.
# 
# Необходимо будет все слова привести к нижнему регистру.
# 
# + В столбце family_status приведена нелогичная группировка, а именно: одновременно присутствуют статусы: "гражданский брак, в разводе, вдовец/вдова". Данные статусы говорят о разном, и не исключают друг друга.
# 
# Необходимо будет оценить распределение статусов между заёмщиками. Возможно потребуется дополнительная категоризация статусов.
# 
# + В столбце total_income, почему-то указано шесть знаков после запятой, и есть один пропуск. Почему доход считается с точностью до шестого знака непонятно. Привести адекватную причину не представляется возможным. Пропуск в столбце total_income, совпадает с пропуском в столбце days_employed.
# 
# Потребуется проверить столбец total_income на пропуски, подумать над причиной возникновения шести знаков после запятой.
# 
# + В столбце purpose цели кредита указны нечётко. Например "покупка жилья" и "покупка жилья для семьи".
# 
# Придётся провести лемматизацию значений столбца, и их категоризацию.

# ### <font color='orange'>Комментарий от наставника 2 итерация 2
# Вывод таблиц в ipython выглядит лучше, если не использовать print, а просто написать `data.head(5)` в одной ячейке и `data.head(20)` в другой.

# In[3]:


print(data['children'].unique())
print(data['children'].value_counts())


# ### <font color='orange'>Комментарий от наставника 3 итерация 2
# Старайся делать только полезные выводы. Вот тут достаточно только вызова `value_counts`, так как его левый столбец и будет как раз содержать все уникальные значения, а значит вызов `unique` излишен.

# # Исследование столбца children.
# 
# 
# Выводим уникальные значений столбца 'children', и количество таких значений.
# 
# В столбце children я обнаружил значения "-1", и "20". Данные значения являются заведомо невозможными, поэтому их необходимо заменить на другие. Поскольку установить количество детей не представляется возможным, я заменил значения на максимально вероятные, а именно: там где значение было "-1" скорее всего имелось в виду "1". А там где "20" - скорее всего имелось в виду "2".
# Есть вариант замены значений на 0, как на самый вероятный вариант. Но варианты с заменой на "1" и "2" мне нравятся больше.

# In[133]:


data.loc[data['children'] == -1, 'children'] = 1
data.loc[data['children'] == 20, 'children'] = 2


# Заменяем заведомо ложные данные о количестве детей.
# 
# -1 ребёнок заменяем на 1 ребёнка, а 20 детей заменяем на 2 детей.

# In[60]:


print(data['dob_days'].unique())
print(data['dob_days'].value_counts())
print(data.groupby('dob_days').count().sort_values(by='dob_days'))


# # Исследование столбца dob_days
# 
# После исследования столбца dob_days видно, что имеется значение 0, что является заведомо неверным. Значение требует замены.
# 
# Основные возраста сформированы в районе 29 - 50 лет, что является абсолютно логичным.
# 
# Группировку данных по возрасту считаю нецелесообразной, поскольку у нас нет задачи подсчёта зависимости кредита от возраста. При необходимости можно будет обращаться не к возрастной группе, а к конкретному возрасту.

# In[134]:


#data_tmp = data.loc[data.loc[:,'dob_days'] != 0]['dob_days']
dop_days_mean = round(data['dob_days'].mean())
print(dop_days_mean)


# ### <font color='orange'>Комментарий от наставника 4 итерация 2 <span style="color:green;font-size:200%">&#10003;</span>
# Вот так проще: `round(data['dob_days'].mean())`. Функция `mean` просто игнорирует и не учитывает null значения.
# 
# ----

# Считаем медиану по столбцу dob_days
# 
# Убираем нули, и считаем медиану по столбцу dob_days. Значение округляем.

# In[135]:


data.loc[data['dob_days'] == 0, 'dob_days'] = dop_days_mean


# В столбце dob_days заменяем нули на медиану

# In[136]:


print(data['gender'].unique())
print(data['gender'].value_counts())


# # Исследование столбца gender
# 
# После исследования столбца gender видно, что имеется значение XNA, что является заведомо неверным. Значение требует замены.
# 
# Поскольку в выборке женщин вдвое больше чем мужчин, то спорное значение заменяем на F
# 
# Иные операции со столбцом невозможны.

# In[137]:


data.loc[data['gender'] == 'XNA', 'gender'] = 'F'


# In[138]:


print(data['days_employed'].unique())


# ### <font color='orange'>Комментарий от наставника 5 итерация 2 <span style="color:green;font-size:200%">&#10003;</span>
# А вот тут от `value_counts` большого толку нет. Этот метод мы используем, когда у нас есть много строк с одинаковыми значениями. И то же касается столбца total_income ниже. Старайся оставлять только те вызовы, которые добавляют нам знаний о датасете причём в максимально информативном виде.

# # Исследование столбца days_employed
# 
# После исследования столбца days_employed видно, что столбец состоит в основном из отрицательных чисел, при этом визуально отрицательные числа могут являться количеством отработанных заёмщиком дней, только со знаком "минус".
# 
# Также в столбцах есть огромные положительные числа, которые не могут являться количеством отработанных дней из-за своей величины. Возможно, что это подитоги. 
# 
# При этом, сам по себе визуальный анализ не может являться основанием для твёрдых выводов, необходимо дополнительное исследование

# In[139]:


data_pivot_tmp = data.pivot_table(index = 'income_type', values = 'days_employed', aggfunc = ['max', 'min', 'median', 'count'])
data_pivot_tmp


# Ищем максимальные, минимальные, значения столбца days_employed. Также считаем медиану и количество значений.
# 
# Формируем сводную таблицу по типам доходов, и полу.
# # Выводы по столбцу days_employed:
# 
# Данные с минусами, это всё-таки количество отработанных дней. Об этом говорит распределение максимальных, минимальных и средних значений по типам дохода: госслужащий, компаньон и сотрудник.
# Анализировать значения по типам: безработный, в декрете, предприниматель и студент - нельзя. Слишком мало значений.
# 
# Вопрос о слишком больших значениях остаётся только по пенсионерам. Скорее всего в обработке данных по пенсионерам имеются ошибки, поскольку предположить стаж в районе 1000 лет нельзя.
# 
# Гипотеза о подитогах не подтвердилась.
# 
# Количество знаков после запятой может быть вызвано неизбежными ошибками (потерями точности) при переводе данных из одного типа в другой. На точность анализа эти ошибки не влияют.
# 
# **Вывод:**
# Условно адекватными значениями для анализа можно признать значения со знаком "минус", если убирать эти минуса.
# Установить причину слишком больших значений не удалось.
# Замена пустых значений возможна только на ноль.

# ### <font color='orange'>Комментарий от наставника 6 итерация 2
# **"Замена пустых значений возможна только на ноль."** Не стоит быть столь категоричным с выводами. Вполне нормальным вариантом тут было бы заменить пропуски медианными значениями по группам income_type. Но это не критично, конечно. Просто осторожнее с очень категоричными выводами. Это аналитика, тут всегда есть несколько вариантов.

# In[140]:


print(data['days_employed'].isnull().sum())
data['days_employed'] = data['days_employed'].fillna(0)
data['days_employed'].isnull().sum()


# ### <font color='orange'>Комментарий от наставника 7 итерация 2 <span style="color:green;font-size:200%">&#10003;</span>
# А вот тут наоброт пригодился бы `print` в первой строке. Ячейки в ipython работают так, что они выводят только значение из последней строки (если не прописан явный print).

# В столбце days_employed заменяем пропущенные значения на 0.
# 
# После замены проверяем наличие пропущенных значений.

# ### <font color='red'> Комментарий наставника 4  <span style="color:green;font-size:200%">&#10003;</span>
# Отлично, что ты нашёл проблемы с огромными и отрицательными числами в столбце days_employed. Но всё же я предлагаю до изменения данных доисследовать это поле и посмотреть на минимальное, максимальное и медианное значения days_employed в разбивке по группам income_type с помощью `pivot_table`.

# ### <font color='red'> Комментарий наставника 5  <span style="color:green;font-size:200%">&#10003;</span>
# Твои наблюдения и выводы вполне логичны. Молодец, что всё объясняешь. Но повторюсь, что нужно не только "рассказывать" про данные, но и показывать их. А ещё лучше писать всё не единым текстом, а небольшими порциями сразу до или после соответствующих изменений.
# 
# ----

# In[141]:


print(data['education'].unique())
print(data['education'].value_counts())


# # Исследование столбца education
# 
# В столбце education видны повторы, связанные с тем, что тип образования набран буквами в разных регистрах. Соответственно, необходимо перевести все буквы в нижний регистр.

# In[142]:


data['education'] = data['education'].str.lower()


# В столбце education всё приводим к нижнему регистру.
# 
# После проведения замены регистра в столбце education, дубликатов там не было. В других столбцах дубликатов также не выявлено, поэтому удалять нечего. (кроме столбца purpose), но его мы будем отрабатывать когда будем категорировать данные.

# In[143]:


print(data['total_income'].unique)
#print(data['total_income'].value_counts())


# # Исследование столбца total_income
# 
# После исследования столбца total_income видно, что каждый столбец total_income является уникальным, а в столбцах есть пропущенные значения.
# 
# Уникальность похоже связана с ошибками при смене типа данных, а пропущенные значения надо заменить.
# Общий объём пропущенных значений составляет 2174 значения, или 10%. Десять процентов строк это много, удалять значения нельзя. Их необходимо заменять.
# Заменять будем на медианное значение дохода по группе income_type.

# In[144]:


print(data['total_income'].isnull().sum())
data['total_income'] = data['total_income'].fillna(0)
data['total_income'].isnull().sum()


# Для вычисления средних значений по типу дохода, необходимо заменить пропущенные значения в столбце total_income, на 0.
# Заменяем.

# In[145]:


data = data.astype({'days_employed': int, 'total_income': int})


# Меняем тип данных в столбцах days_employed и total_income на целочисленный.
# 
# Для изменения типа данных, использовал метод astype. Использовал, потому что это удобно.

# In[146]:


def income_median (data_tmp, income_type):
    return data_tmp.loc[data_tmp.loc[:, 'income_type'] == income_type]['total_income'].median()

income_type_lst = data['income_type'].unique()
data_tmp = data.loc[data['total_income'] != 0]
income_type_len = len(income_type_lst)
i = 0
income_type_dict = {}
for i in range(income_type_len):
    keyi = income_type_lst[i]
    valuei = income_median(data_tmp, income_type_lst[i])
    income_type_dict[keyi] = valuei
    i += 1

print(income_type_dict)


# Вычислил медианные значения по группам доходов. При этом, для вычисления строки с нулевым уровнем дохода удалены.
# 
# Получил словарь, где ключами являются типы дохода, а значениями - медианный уровень дохода. Теперь надо заменить нули в основной таблице на медианные значения.

# In[ ]:


def type_inc_func (x, y):
    if x == 0:
        return income_type_dict.get(y)
    else:
        return x

data['total_income'] = data.apply(lambda x: type_inc_func(x['total_income'], x['income_type']), axis = 1)


# Заменил нули в столбце total_income на медианные значения, по типам income_type.
# Для замены использовал словарь выше.

# ### <font color='orange'>Комментарий от наставника 8 итерация 2
# Молодец, что учёл мой комментарий и заменил данные исходя из среднего внутрик группы income_type! Твой вариант вполне корректен, но можно ещё проще:

# In[149]:


# НАСТАВНИК: вот такой код заменяет две ячейки выше:
# находим среднее по группам income_type:
dob_years_mean_by_income_type_dict = data.groupby('income_type')['total_income'].agg('mean').to_dict() 
# посмотрим на получившийся словарь:
print(dob_years_mean_by_income_type_dict) 
# создадим новый столбец со средними по группе income_type (в самом конце посмотрим, что вышло)
data['total_income_mean'] = data['income_type'].map(dob_years_mean_by_income_type_dict)
data.loc[data['total_income'] == 0, 'total_income'] = data.loc[data['total_income'] == 0, 'total_income_mean']
data[['total_income', 'total_income_mean', 'income_type']].head(10)  # убедимся, что всё ок


# ### <font color='red'> Комментарий наставника 6  <span style="color:green;font-size:200%">&#10003;</span>
# Немного более аккуратным вариантом замены пропусков в total_income могла бы быть замена на медианные значения по группам income_type. А еще имеет смысл сказать о том, какой процент данных пропущен.

# ### <font color='red'> Комментарий наставника 7  <span style="color:green;font-size:200%">&#10003;</span>
# Молодец, что нашёл дубли из-за регистра в столбце education. Но опять же, давай перед изменениями показывать проблемы.

# In[150]:


from pymystem3 import Mystem
m = Mystem()
lm = data['purpose'].unique()
lemmas_unique = set()
for sublist in lm:
    b = sublist.split()
    for item in b:
        lemmas_unique.add(item)
lemmas_unique = list(lemmas_unique)
lemmas = set()
i = 0
for word in lemmas_unique:
    lemmas_tmp = m.lemmatize(lemmas_unique[i])
    i += 1
    lemmas.add(lemmas_tmp[0])
print(lemmas)


# ### <font color='orange'>Комментарий от наставника 9 итерация 2 <span style="color:green;font-size:200%">&#10003;</span>
# Обращу внимание, что lemmas_unique содержат не уникальные леммы. Это легко заметить, если их вывести. Чтобы леммы были уникальны нужно было использовать не list, а set:
#     
# ```
# lemmas_unique = set()
# ...
#         lemmas_unique.add(item)
#     
# ```
# 
# ----

# Лемматизация целей кредита осуществлялась следующим образом:
# 
# 
# Сначала все уникальные цели кредита были записаны в один список. Получился список, из целей кредита. Каждая цель раскладывалась по буквам. Лемматизировать цели в таком виде нельзя, лемматизировать нужно слова.
# Слова были положены в единый список через цикл.
# 
# 
# Далее, каждое слова списка было лемматизированно, и лемматизированное было добавлено итоговый в список с леммами.
# 
# Список с леммами был визуально проанализирован, чтобы сгруппировать цели кредита по видам.

# ### <font color='red'> Комментарий наставника 8 <span style="color:green;font-size:200%">&#10003;</span>
# У тебя получилось получить леммы, которые встречаются в целях, молодец! Но к сожалению, совсем не понятно, как ты их затем использовал.

# ### <font color='orange'>Комментарий от наставника 10 итерация 2 <span style="color:green;font-size:200%">&#10003;</span>
# Я имела в виду, что стоит вывести полученный столбец с lemmas.

# ### <font color='green'>Комментарий для наставника
# 
# Извини, понятней не стало. Я просто вывел множество с леммами.
# 
# Может надо было добавить леммы в основную таблицу? Вообще не понимаю зачем.
# 
# Название переменной - lemmas_unique вводит в заблуждение. В нём не уникальные леммы, а список уникальных слов из столбца "purpose".
# 
# Леммы в столбце - lemmas. Но я сделал множества и там, и там.
# 
# Парадокс. Я сам хотел сначала использовать множества но не получалось. Поэтому пошёл списком. Ты сказала делай множества - получилось.

# ### <font color='blue'>Комментарий от наставника 1 итерация 3
# Отлично, что получилось :)
# 
# Да, просто хотела увидеть `print`, его до этой итерации не было. Теперь всё ок.

# In[151]:


def child_id (child):
    if 0 <= child <= 2:
        return child
    elif child >= 3:
        return '3+'

    
data['children_id'] = data['children'].apply(child_id)


# Группируем заёмщиков по количеству детей. Количество детей - одна группа. Всего четыре группы, первая группа - 0 детей, последняя - три ребёнка и более.

# In[152]:


data['family_status'] = data['family_status'].replace('Не женат / не замужем', 'не в браке')


# Производить категорирование столбца family_status не требуется. Существующие позиции, вполне выполняют функции категорий, при этом, для выводов будут нужны именно наименования статусов, а не цифры.
# 
# Для сокращения ширины колонок сводной таблицы, поле 'Не женат / не замужем', заменено на поле 'не в браке'
# Для того, чтобы в сводной таблице данные отображались отсортированно, производим замену названий строк

# In[153]:


print(len(data) / 5)


# ### <font color='orange'>Комментарий от наставника 11 итерация 2 <span style="color:green;font-size:200%">&#10003;</span>
# Старайся никогда руками не копировать числа. Вместо этого стоит создавать переменные. В данному случае стоило вместо числа 21525 использовать выражение `len(data)`.
# 
# Это нужно для того, чтобы повысить переиспользуемость кода. Представь, что завтра нам дадут новый дополненный датасет с большим числом строк. Если руками копировать числа, то мы не сможем так просто переиспользовать свой код.
# 
# ----

# Для того чтобы группировать заёмщиков по уровням дохода нужно выбрать определённый подход. Я взял подход, который используется Росстатом, а именно - разделение заёмщиков на 20% группы. То есть в первой группе 20% заёмщиков с самым низким доходом, во второй 20% с самым низким из оставшихся и так далее.
# 
# 
# Для корректной группировки необходимо отсортировать таблицу по уровню дохода.
# Далее необходимо определить границы каждой группы. Шаг каждой группы это - 20% от общего количества заёмщиков.
# Для расчёта границ воспользуемся общим количеством строк в таблице - 21525. Получилось 4305 заёмщиков в каждой группе.

# ### <font color='orange'>Комментарий от наставника 12 итерация 2 <span style="color:green;font-size:200%">&#10003;</span>
# Такой подход очень хороший. Он не новый, и в математике такое называется перцентилями. см http://wikiredia.ru/wiki/Перцентиль<br>
# Процитирую википедию: "Фраза «90-й процентиль массы тела у новорожденных мальчиков составляет 4 кг» означает, что 90% мальчиков рождаются с весом меньше, либо равным 4 кг, а 10% мальчиков рождаются с весом больше 4 кг."<br>
# Таким образом нам нужно найти 20%, 40%, 60% и 80% перцентили и сделать из них границы для нашего разделения. <br>
# Для этого нужно воспользоваться методом `describe`:<br>
# `data['total_income'].describe(percentiles=[0.2, 0.4, 0.6, 0.8])`
#     
# Дальше можно написать функцию, в котором поступаем значение total_income и на выходе мы возвращаем категорию и затем выполнить apply этой функции.
# 
# Предлагаю попробовать тебе заменить ручные манипуляции ниже на использование перцентилей:

# In[154]:


# НАСТАВНИК:
total_income_info = data['total_income'].describe(percentiles=[0.2, 0.4, 0.6, 0.8])
#print(total_income_info)
total_income_percentile_20 = total_income_info["20%"]
total_income_percentile_40 = total_income_info["40%"]
total_income_percentile_60 = total_income_info["60%"]
total_income_percentile_80 = total_income_info["80%"]
total_income_percentile_max = total_income_info["max"]
print(total_income_percentile_20)  # Получается, что у 20% всех людей из датасета зарплата меньше 98661.6
print(total_income_percentile_40)  # Получается, что у 40% всех людей из датасета зарплата меньше 132141.8
print(total_income_percentile_60)  # Получается, что у 60% всех людей из датасета зарплата меньше 161151.2
print(round(total_income_percentile_80, 1))  # Получается, что у 80% всех людей из датасета зарплата меньше 214269.6
print(total_income_percentile_max)  # Получается, что максимальная зарплата всех людей из датасета зарплата 2265604.0


# In[155]:


def total_income_id_func (total_income):
    if total_income <= total_income_percentile_20:
        return '1группа0-20%'
    elif total_income_percentile_20 < total_income <= total_income_percentile_40:
        return '2группа20-40%'
    elif total_income_percentile_40 < total_income <= total_income_percentile_60:
        return '3группа40-60%'
    elif total_income_percentile_60 < total_income <= total_income_percentile_80:
        return '4Четвёртые60-80%'
    elif total_income <= total_income_percentile_max:
        return '5Пятые80-100%'

    
data['income_id'] = data['total_income'].apply(total_income_id_func)


# Распределяем людей по 20% группам, а зависимости от доходов. Соответствующую группу прописываем в основную таблицу.

# Вычисляем границы диапазонов для индексов заёмщиков. Первое значение списка должно быть равно 0, а последнее - числу записей в таблице.
# 
# Соответственно, беднейшие заёмщики попадают в первую группу. Богатейшие - в пятую.

# data = data.sort_values(by = 'total_income')
# data = data.reset_index(drop=True)
# data.loc[int_income_lst[0]:int_income_lst[1] - 1, 'income_id'] = '1группа0-20%'
# data.loc[int_income_lst[1]:int_income_lst[2] - 1, 'income_id'] = '2группа20-40%'
# data.loc[int_income_lst[2]:int_income_lst[3] - 1, 'income_id'] = '3группа40-60%'
# data.loc[int_income_lst[3]:int_income_lst[4] - 1, 'income_id'] = '4Четвёртые60-80%'
# data.loc[int_income_lst[4]:int_income_lst[5] - 1, 'income_id'] = '5Пятые80-100%'

# ### <font color='red'> Комментарий наставника 9 <span style="color:green;font-size:200%">&#10003;</span>
# К сожалению, совсем не ясно, что происходит выше. Давай добавим комментарии о том, что тут происходит, что за диапазоны строк, почему именно они и чего мы хотим добиться.<br>
# Ну и ещё в любом случае тебе не стоит так работать с данными. Старайся делать свой код переиспользуемым. Представь, что завтра тебе дадут другой датасет (исправленный, дополненный новыми данными). Тебе следует писать такой код, который легко можно будет переиспользовать.

# Таблица с данными отсортирована, 20% группы заёмщиков сформированы по индексам.

# In[156]:


def prps_id (prps):
    if 'автомоб' in prps:
        return 'Автомобиль'
    elif 'строител' in prps:
        return 'Недвижимость'
    elif 'недвижимос' in prps:
        return 'Недвижимость'
    elif 'жиль' in prps:
        return 'Недвижимость'
    elif 'образован' in prps:
        return 'Образование'
    elif 'свад' in prps:
        return 'Свадьба'
    
data['prps_cat'] = data['purpose'].apply(prps_id)


# ### <font color='red'> Комментарий наставника 10  <span style="color:green;font-size:200%">&#10003;</span>
# Молодец, ты выделил вполне логичные 4 категории. Но давай вместо введения не информативных идентификаторов добавим словестные категории. Вместо столбца purpose_id добавим столбец purpose_category. И в функции выше вернём не 3, а "образование". А вместо 1 вернём "операции с недвижимостью" и т.д.

# Таким образом, категоризированы следующие данные:
#     количество детей
#     семейное положение
#     уровень дохода
#     цель кредита

# In[157]:


data_pivot = data.pivot_table(index = 'income_id', values = 'debt', aggfunc = ['count', 'sum'])
data_pivot['risk%'] = data_pivot['sum']['debt'] / data_pivot['count']['debt'] * 100
print(round(data_pivot['risk%'], 2))


# # Выводы по влиянию уровня дохода на платёжную дисциплину
# 
# Я не вижу явной и чёткой зависимости уровня дохода, на своевременность возврата. Разница между минимальным процентом проблемных заёмщиков - 7,02%, и максимальным - 8,69 - незначительна.
# 
# Общий уровень проблемных заёмщиков в первых четырёх 20% группах около 8,5%. Отдельно выделяется группа 20% самых состоятельных заёмщиков с уровем 7.02%.
# 
# Разницу считаю незначительной в итоговую сводную таблицу включать поле total_income не буду.

# In[158]:


data_pivot1 = data.pivot_table(index = 'children_id', values = 'debt', aggfunc = ['count', 'sum'])
data_pivot1['risk%'] = data_pivot1['sum']['debt'] / data_pivot1['count']['debt'] * 100
print(round(data_pivot1['risk%'], 2))


# # Выводы по влиянию количества детей на платёжную дисциплину
# 
# Есть чёткое влияние вероятности проблем с кредитами, от количества детей.
# 
# Лучше всего кредиты обслуживают люди без детей - 7,51%.
# 
# Хуже всего - люди с одним или двумя детьми. Процент проблемных заёмщиков составляет около 9,3%
# 
# Среди людей с тремя и более детьми, доля проблемных заёмщиков составляет около 8,16%. 

# In[159]:


data_pivot3 = data.pivot_table(index = 'family_status', values = 'debt', aggfunc = ['count', 'sum'])
data_pivot3['risk%'] = data_pivot3['sum']['debt'] / data_pivot3['count']['debt'] * 100
print(round(data_pivot3['risk%'], 2))


# # Выводы по влиянию семейного статуса на платёжную дисциплину
# 
# Влияние семейного статуса на своевременность возврата является максимальной. От 6,5% до 9,7%. Разница очень значительная.
# 
# Лучше всего кредиты вдовы - 6,56%.
# 
# Хуже всего - люди не состоящие в браке, где процент проблемных заёмщиков составляет 9,74%
# 
# Группировка остальных статусов невозможна, расхождение достаточно значительное. 

# In[160]:


data_pivot4 = data.pivot_table(index = 'prps_cat', values = 'debt', aggfunc = ['count', 'sum'])
data_pivot4['risk%'] = data_pivot4['sum']['debt'] / data_pivot4['count']['debt'] * 100
print(round(data_pivot4['risk%'], 2))


# # Выводы по влиянию цели кредита на платёжную дисциплину
# 
# Есть чёткое влияние вероятности проблем с кредитами, от цели кредита.
# 
# Лучше всего обслуживаются кредиты связанные с недвижимостью - 7,21% проблемных заёмщиков.
# 
# Хуже всего - кредиты, взятые на автомобиль и образование. Процент проблемных заёмщиков составляет около 9,25%
# 
# Неочевидным результатом является величина проблемых заёмщиков, взявших кредит на свадьбу - 7,92%.

# ### <font color='red'> Комментарий наставника 11 <span style="color:green;font-size:200%">&#10003;</span>
# Твои результаты вполне корректны, но читать таблицы выше, к сожалению, очень сложно.<br>
# Вместо groupby тут стоит использовать сводные таблицы `pivot_table`. При этом твои таблицы должны быть наглядными и по ним сразу должно быть понятно, что происходит и какие из этого можно сделать выводы. При этом стоит сопровождать свой код комментариями.

# # Вводная часть
# 
# Для анализа были представлены данные о заёмщиках, с указанием, были ли просрочки с оплатой кредита.
# Была поставлена задача установить, как влияет на своевременность обслуживания кредита следующие факторы: (наличие детей, семейное положение, уровень дохода и цель кредита).
# 
# В представленных данных информация о детях, семейном положении, уровне дохода и цели кредита была указана.
# 
# В представленных данных около 10% записей не имело данных об уровне дохода. В отношении этих заёмщиков доход был рассчитан как медианое значение дохода социальной группы заёмщика. Также незначительные замены были в данных о детях.
# Замены не повлияли на результаты исследования.
# 
# 
# 
# # Дети
# **Вопрос: Есть ли зависимость между наличием детей и возвратом кредита в срок?**  
# 
# Ответ: Да. Лучшую платёжную дисциплину демонстрируют заёмщики без детей - 7.51% проблемных заёмщиков. Худшую - те заёмщики у которых один, или два ребёнка - 9.15% и 9.48% проблемных заёмщиков соответственно. Заёмщики, имеющие трёх и более детей, несвоевременно возвращали кредиты в 8.16% случаях.
# 
# Пояснение:  Поскольку дети обходятся дорого, то наличие детей в семье, делает семью менее финансово устойчивой, и способной своевременно погашать кредит. При этом, семьи где есть трое и более детей - обладают большей платёжной дисциплиной.
# 
# Предполагаю, что люди, имеющие более трёх детей, сами по себе более ответственны, и меньше склонны к потребительству и необдуманным тратам, что позволяет им более аккуратно гасить кредиты.
# 
# 
# 
# 
# # Семейное положение
# **Вопрос: Есть ли зависимость между семейным положением и возвратом кредита в срок?**
# 
# Ответ: Да. Лучшую платёжную дисциплину демонстрируют вдовы / вдовцы - 6,56% проблемных кредитов. А худшую - люди не состоящие в браке - 9,74% проблемных кредитов. 
# Люди в разводе допускают просрочки в 7,11% случаях, женатые/замужние в 7,52%, люди состоящие в гражданском браке - в 9,29%.
# 
# Пояснение: Не женатые / не замужние не обладают поддержкой партнёра, поэтому их финансовое положение и способность гасить кредиты менее устойчива. Предполагаю, что вдовы / вдовцы, обладают лучшей финансовой дисциплиной, поскольку имели травмирующий опыт, приведший к большей ответственности. Аналогично по людям в разводе. Женатые / замужние люди, с одной стороны не имеют опыта аналогичного вдовцам и разведённым людям, а с другой - обладают поддержкой партнёра, что позволяет им гасить кредиты более аккуратно.
# 
# # Уровень дохода
# **Вопрос: Есть ли зависимость между уровнем дохода и возвратом кредита в срок?**
# 
# Ответ: Нет. Уровень расхождений между группами заёмщиков по доходу считаю недостаточным для такого вывода. Разница между наиболее дисциплинированными заёмщиками (20% самых высокооплачиваемых) с 7,02% просрочки, и наиболее недисциплинированными (средние доходы) с 8,69% является незначительной. 80% беднейших заёмщиков, допускают просроку с вероятностью примерно 8,3%.
# 
# Пояснение: Своеобразный и неочевидный вывод, возможно, потому что чем больше доход - тем больше кредит. При этом, 20% самых высооплачиваемых людей платят кредиты лучше всех. Возможно, это из-за того, что люди более ответственны. 
# 
# # Цель кредита
# **Вопрос: Как разные цели кредита влияют на его возврат в срок?**
# 
# 
# Ответ: Кредиты, выдаваемые для операций с недвижимостью, обслуживаются лучше всего - 7,21% проблемных кредитов. Хуже всего обслуживаются кредиты на автомобиль, и образование, примерно 9,3% просрочек. Кредиты, выдаваемые на свадьбу, обслуживаются с просрочками в 7,92% случаях.
# 
# Пояснение: Возможно, из-за более качественного залога, возможно из-за того что кредит на недвижимость иногда позволяет получать дополнительный доход (сдача в аренду), или сократить расходы (не платить за аренду).
# Кредиты на автомобиль обслуживаются хуже всего, поскольку автомобиль обычно добавляет расходов.
# Кредиты на образование также обслуживаются плохо, потому что платежи нужно вносить сразу, в период когда возможности для заработка снижаются, а не повышаются, поскольку нужно не только работать, но и учиться.

# In[161]:


data_pivot_tot = data.pivot_table(index = ['family_status', 'prps_cat'], columns = 'children_id', values = 'debt', aggfunc = ['sum', 'count'])
data_pivot_tot   # НАСТАВНИК: я убрала слово print и сразу вывод стал сильно приятнее:


# В таблице видим значения Nan. От него необходимо избавиться, избавляемся и печатаем таблицу заново.

# In[162]:


data_pivot_tot.fillna(0, inplace=True)
data_pivot_tot # НАСТАВНИК: я убрала слово print и сразу вывод стал сильно приятнее:


# # Итоговая сводная таблица (количество кредитов)
# 
# Все данные группируем в одну итоговую сводную таблицу, где по строкам группируем данные по семейному статусу и цели кредита. По столбцам группируем данные по количеству детей. Данная группировка вызвана тем, что на свадьбу берут кредиты только люди состоящие в гражданском браке.
# 
# В таблице представлено количество проблемных кредитов, по группам, и общее число выданных кредитов, также по группам.
# 
# Проценты невозврата по группам будут представлены ниже. Эти таблицы целесообразно использовать для оценки выборки. То есть сколько кредитов всего выдавалось, по видам заёмщиков.
# 
# Чтобы адекватно оценить цифры процентов по всевозможным видам заёмщиков, надо знать сколько кредитов выдано каждой группе заёмщиков.

# # Выводы по итоговой сводной таблице (количество кредитов)
# 
# Кредиты, выданные заёмщикам, с тремя и более детьми, имеющими статусы: в разводе, вдовец, не в браке - является минимальным. Что логично, таких людей действительно мало. Также мало было выдано кредитов, людям состоящим в гражданском браке на автомобиль и образование.
# 
# Также мало выдано кредитов заёмщикам, с двумя детьми, имеющими статус вдовец/вдова. И кредитов на автомобиль, выданных вдовцам с одним ребёнком.
# 
# Соответственно, делать какие-либо выводы о доле невозвратов по этим категориям нельзя. 
# 
# Это нам поможет когда будем оценивать долю невозвратов по группе.

# In[163]:


data_pivot_tot['risk_0дет'] = round(data_pivot_tot['sum'][0] / data_pivot_tot['count'][0] * 100, 2)
data_pivot_tot['risk_1дет'] = round(data_pivot_tot['sum'][1] / data_pivot_tot['count'][1] * 100, 2)
data_pivot_tot['risk_2дет'] = round(data_pivot_tot['sum'][2] / data_pivot_tot['count'][2] * 100, 2)
data_pivot_tot['risk3+дет'] = round(data_pivot_tot['sum']['3+'] / data_pivot_tot['count']['3+'] * 100, 2)
data_total = data_pivot_tot.copy()
del data_total['sum']
del data_total['count']
data_total # НАСТАВНИК: я убрала слово print и сразу вывод стал сильно приятнее:


# # Выводы по общей сводной таблице
# 
# В одну таблицу сведены проценты невозврата по семейному статусу, целям кредита и количеству детей.
# Поскольку кредиты на свадьбу берут только люди, состоящие в гражданском браке, то столбцы сгруппированы по семейному статусу и цели кредитования. А количество детей отражено в столбцах.
# 
# Выводы по сводной таблице соответствуют выводам по типам группировки. Лучше всего обслуживают кредиты женатые семьи без детей, взявшие кредит на недвижимость.
# 
# Хуже всего кредиты обслуживают люди не состоящие в браке, с одним или двумя детьми, взятые на автомобиль или образование.
# 
# ## Области максимального риска:
# 
# Максимально рискованными являются кредиты для холостых людей с двумя детьми, взятых на автомобиль - 23,81%, что соотносится в рисками по каждой группировке в отдельности. Значения более 23,81, в таблице присутствуют, но они не являются показательными из-за малой выборки.
# 
# Сопоставимые уровни риска отмечены для кредитов, выданных людям состоящим в гражданском браке, имеющим одного или двух детей, выданных на образование.
# 
# ## Области минимального риска:
# 
# Минимальный риск отмечен при выдаче кредитов разведённым людям, с одним ребёнком, выданным на образование - 3.28%. Значения 0%, в таблице присутствуют, но не являются показательными из-за малой выборки.
# 
# Также в зону минимального риска попадают кредиты выданные вдовцам без детей на недвижимость - 4.67%, и женатым людям, с тремя и более детьми на образование - 4.62.
# 
# Заёмщики с сочетанием всех низкорискованных факторов (женатые без детей, взявшие кредит на недвижимость) имеют процент просрочек - 6.55% (эталонный уровень). Аналогичный уровень просрочек достаточно широко распространнен, прежде всего по кредитам выданным на недвижимость, и по кредитам выданным семьям без детей.
# 
# # Статистические аномалии:
# 
# Заёмщики, состоящие в гражданском браке, обслуживают кредиты на свадьбу существенно лучше чем на недвижимость! Уникальный, неочевидный, совершенно непонятный факт. На максимальной выборке соотношение просрочки по кредитам выданным на свадьбу, против кредитов, выданных на недвижимость составляет - 7,41% против 7,85%! Дальше расхождение увеличивается в пользу кредитов выданных на свадьбу.
# 
# Кредиты, выданные на образование женатым людям с тремя детьми имеют просрочку всего 4.62%, что меньше чем кредиты выданные женатым же, но на недвижимость и без детей (в худшую сторону сдвинулось два фактора из трёх).
# 
# Очень низкую просрочку имеют кредиты выданные семьям с двумя детьми на свадьбу, проживающие в гражданском браке - 6.67%. Два фактора риска, один фактор неопределённый, а уровень почти равен эталонному.
# 
# Минимальный риск отмечен при выдаче кредитов разведённым людям, с одним ребёнком, выданным на образование - 3.28%. Статистическая аномалия, поскольку два фактора, "один ребёнок", и "образование", противоречат этому выводу.
# 
# Аномалий, по сверхвысоким рискам, не установлено. Условно в такую аномалию можно записать кредиты выданные холостым людям, имеющим трёх и более детей на недвижимость. Уровень проблем при возврате - 66%. Но выдано всего три кредита, поэтому выводов здесь я не делаю.

# ### <font color='red'> Комментарий наставника по выводам  <span style="color:green;font-size:200%">&#10003;</span>
# 
# У тебя хорошие, вполне логичные выводы. Ты вполне логично отвечаешь на поставленные вопросы. Но при этом всё-таки можно их немного улучшить, есть сделать следующее:
# 
# 1. В начале общего вывода стоит ещё раз упомянуть решаемую задачу.
# 2. Стоит сказать о проблемах, которые есть в данных и о том, могли ли они повлиять на результаты.
# 3. В выводах стоит добавить числа, на которые ты опираешься (лучше всего проценты невозврата)
# 
# В целом представь, что общий вывод ты пишешь для менеджера, у которого нет времени вникать во все детали твоего исследования, но при этом он хочет получить довольно полную картину.

# ### <font color='red'> Комментарий наставника всему проекту  <span style="color:green;font-size:200%">&#10003;</span>
#     
# Ты нашёл все проблемы с данными, исправил их, заполнил пропуски и вполне корректно ответил на вопросы, молодец!<br>
# Но всё же тебе стоит научиться оформлять результаты так, чтобы другой человек смотрел на твоё исследование и у него не оставалось вопросов.
# 
# Лучше всего поправить все указанные мной замечания. Но для того, чтобы работа была зачтена, как минимум нужно исправить следующее:
# 1. Добавить первичное исследование данных (комментарий 3) <span style="color:green;font-size:200%">&#10003;</span>
# 2. Перед каждой заменой данных показывать проблемы  <span style="color:green;font-size:200%">&#10003;</span>
# 3. Заменить id категорий на словестные описания и собрать данные в понятные сводные таблицы (комментарии 10 и 11) <span style="color:green;font-size:200%">&#10003;</span>
# 4. Структурировать своё исследование, выделив отдельные логические блоки с помощью markdown с заголовками. Комментарии при этом писать рядом с соответствующим кодом. <span style="color:green;font-size:200%">&#10003;</span>
# 5. Исправить комментарий 9. <span style="color:green;font-size:200%">&#10003;</span>
# 6. Дополнить общий вывод <span style="color:green;font-size:200%">&#10003;</span>

# ### <font color='orange'>Комментарий наставника по всему проекту итерация 2 <span style="color:green;font-size:200%">&#10003;</span>
# Спасибо, что исправил все мои замечания! После исправлений проект стал существенно проще читаться, молодец! Я добавила ещё не мало комментариев. Они помогут тебе сделать код ещё лучше. Но все они не критичные.
#     
# Я предлагаю тебе поступить следующий образом. Пожалуйста, посмотри на мои комментарии и, если у тебя будет время, то исправь их. Если времени свободного совсем нет, то просто отправь мне обратно работу с комментарием в самом начале или конце о том, что времени нет, и ты хочешь, чтобы я приняла работу. И я сразу её приму.

# In[ ]:




