import pandas as pd
import numpy as np
from scipy import stats as st
calls_df = pd.read_csv('/datasets/calls.csv')
internet_df = pd.read_csv('/datasets/internet.csv')
sms_df = pd.read_csv('/datasets/messages.csv')
tariffs_df = pd.read_csv('/datasets/tariffs.csv')
users_df = pd.read_csv('/datasets/users.csv')
calls_df.info()
calls_df.head()
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 202607 entries, 0 to 202606
Data columns (total 4 columns):
id           202607 non-null object
call_date    202607 non-null object
duration     202607 non-null float64
user_id      202607 non-null int64
dtypes: float64(1), int64(1), object(2)
memory usage: 6.2+ MB
id	call_date	duration	user_id
0	1000_0	2018-07-25	0.00	1000
1	1000_1	2018-08-17	0.00	1000
2	1000_2	2018-06-11	2.85	1000
3	1000_3	2018-09-21	13.80	1000
4	1000_4	2018-12-15	5.18	1000
calls_df['duration'].hist()

<matplotlib.axes._subplots.AxesSubplot at 0x7fe0d4c1b198>
В таблице calls_df пропусков нет. При этом, в таблице имеются звонки с длительностью 0 минут, и с нецелым количеством минут. Для работы с данными, звонки длительностью 0 минут необходимо удалить, поскольку фактически звонок не осуществлён (соединения с абонентом не произведено). Для расчётов нам необходимо целое количество минут, округлённое в большую сторону.


import math

calls_df = calls_df.query('duration != 0')
calls_df['duration'] = calls_df['duration'].apply(math.ceil)
calls_df['duration'].astype('int')
calls_df['duration'].unique()
array([ 3, 14,  6, 19,  8, 10,  5, 13, 16,  9,  2, 15, 11, 24, 12, 23,  7,
       20,  1,  4, 17, 21, 18, 25, 22, 27, 26, 29, 28, 30, 37, 31, 33, 34,
       32, 36, 35, 38])

Убираем из таблицы все значения с нулём минут. Округляем длительность разговора в большую сторону. Переводим тип данных в int. Проверяем уникальные значения.

internet_df.info()
internet_df.head()
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 149396 entries, 0 to 149395
Data columns (total 4 columns):
id              149396 non-null object
mb_used         149396 non-null float64
session_date    149396 non-null object
user_id         149396 non-null int64
dtypes: float64(1), int64(1), object(2)
memory usage: 4.6+ MB
id	mb_used	session_date	user_id
0	1000_0	112.95	2018-11-25	1000
1	1000_1	1052.81	2018-09-07	1000
2	1000_2	1197.26	2018-06-25	1000
3	1000_3	550.27	2018-08-22	1000
4	1000_4	302.56	2018-09-24	1000
internet_df['mb_used'].hist()
internet_df = internet_df.query('mb_used != 0')
internet_df['mb_used'] = internet_df['mb_used'].apply(math.ceil)
internet_df['mb_used'].unique()
array([ 113, 1053, 1198, ..., 1540, 1346, 1388])


В таблице internet_df пропуски и нули не выявлены. Убираем возможные нули. Округляем траффик до мегабайтов в большую сторону. Строим гистограмму по количеству потреблённых мегабайт. Видим красивый, очень правдоподобный график. Никаких особенных значений не выявлено. Оставляем как есть.

sms_df.info()
sms_df.head()
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 123036 entries, 0 to 123035
Data columns (total 3 columns):
id              123036 non-null object
message_date    123036 non-null object
user_id         123036 non-null int64
dtypes: int64(1), object(2)
memory usage: 2.8+ MB
id	message_date	user_id
0	1000_0	2018-06-27	1000
1	1000_1	2018-10-08	1000
2	1000_2	2018-08-04	1000
3	1000_3	2018-06-16	1000
4	1000_4	2018-12-05	1000
Пропусков не выявлено. Здесь каждый id - это факт смс. Поэтому единственное что может быть - это пропуски. Пропусков не выявленго, оставляем всё как есть. Обработка не требуется.

tariffs_df.info()
tariffs_df.head()
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 2 entries, 0 to 1
Data columns (total 8 columns):
messages_included        2 non-null int64
mg_per_month_included    2 non-null int64
minutes_included         2 non-null int64
rub_monthly_fee          2 non-null int64
rub_per_gb               2 non-null int64
rub_per_message          2 non-null int64
rub_per_minute           2 non-null int64
tariff_name              2 non-null object
dtypes: int64(7), object(1)
memory usage: 208.0+ bytes
messages_included	mg_per_month_included	minutes_included	rub_monthly_fee	rub_per_gb	rub_per_message	rub_per_minute	tariff_name
0	50	15360	500	550	200	3	3	smart
1	1000	30720	3000	1950	150	1	1	ultra
users_df.info()
users_df.head()
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 500 entries, 0 to 499
Data columns (total 8 columns):
user_id       500 non-null int64
age           500 non-null int64
churn_date    38 non-null object
city          500 non-null object
first_name    500 non-null object
last_name     500 non-null object
reg_date      500 non-null object
tariff        500 non-null object
dtypes: int64(2), object(6)
memory usage: 31.3+ KB
user_id	age	churn_date	city	first_name	last_name	reg_date	tariff
0	1000	52	NaN	Краснодар	Рафаил	Верещагин	2018-05-25	ultra
1	1001	41	NaN	Москва	Иван	Ежов	2018-11-01	smart
2	1002	59	NaN	Стерлитамак	Евгений	Абрамович	2018-06-17	smart
3	1003	23	NaN	Москва	Белла	Белякова	2018-08-17	ultra
4	1004	68	NaN	Новокузнецк	Татьяна	Авдеенко	2018-05-14	ultra
В таблице о тарифах никакой обработки и изменений не требуется. В таблице о пользователях, есть пропуски в столбце churn_date, то есть - дата прекращения использования тарифа. Поскольку мы работаем только с 2018 годом, то целесообразна замена на дату 31.12.2018. Заменяем на это число и проверяем.

Также в таблице users_df, вычисляем месяц регистрации (mnth_reg), и общий срок действия договора в месяцах, для каждого пользователя. Нам понадобятся эти значения для расчёта помесячных значений.

users_df['churn_date'] = users_df['churn_date'].fillna('2018-12-31')
users_df['mnth_reg'] = pd.DatetimeIndex(users_df['reg_date']).month
users_df['mnth_chrn'] = pd.DatetimeIndex(users_df['churn_date']).month
users_df['mnth_ttl'] = users_df['mnth_chrn'] - users_df['mnth_reg'] + 1
users_df.info()
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 500 entries, 0 to 499
Data columns (total 11 columns):
user_id       500 non-null int64
age           500 non-null int64
churn_date    500 non-null object
city          500 non-null object
first_name    500 non-null object
last_name     500 non-null object
reg_date      500 non-null object
tariff        500 non-null object
mnth_reg      500 non-null int64
mnth_chrn     500 non-null int64
mnth_ttl      500 non-null int64
dtypes: int64(5), object(6)
memory usage: 43.0+ KB
sms_df['month'] = pd.DatetimeIndex(sms_df['message_date']).month
sms_df.head(10)
id	message_date	user_id	month
0	1000_0	2018-06-27	1000	6
1	1000_1	2018-10-08	1000	10
2	1000_2	2018-08-04	1000	8
3	1000_3	2018-06-16	1000	6
4	1000_4	2018-12-05	1000	12
5	1000_5	2018-06-20	1000	6
6	1000_6	2018-11-19	1000	11
7	1000_7	2018-10-29	1000	10
8	1000_8	2018-06-25	1000	6
9	1000_9	2018-12-18	1000	12
calls_df['month'] = pd.DatetimeIndex(calls_df['call_date']).month
internet_df['month'] = pd.DatetimeIndex(internet_df['session_date']).month
Из столбца call_date выделяем месяц звонка, и для каждого звонка указываем, в каком месяце этот звонок был. Далее формируем итоговую таблицу, где в каждой строке указыавем отдельного абонента, и по каждому абоненту, формируем помесячную длительность разговоров, и общее количество разговоров.

Аналогично делаем по количеству смс, и трафику.

calls_df_by_user_month = calls_df.pivot_table(index='user_id', columns='month', values = 'duration', aggfunc='sum')
calls_count_df_by_user_month = calls_df.pivot_table(index='user_id', columns='month', values = 'duration', aggfunc='count')
Подсчёт количества сделанных звонков для каждого пользователя помесячно.
Теперь мы знаем количество сделанных звонков (соединений, длительностью одна минута и более), по каждому пользователю, за каждый месяц. Значение Nan не удаляем, и не заменяем,

calls_df_by_user_month.head()
month	1	2	3	4	5	6	7	8	9	10	11	12
user_id												
1000	NaN	NaN	NaN	NaN	159.0	172.0	340.0	408.0	466.0	350.0	338.0	333.0
1001	NaN	NaN	NaN	NaN	NaN	NaN	NaN	NaN	NaN	NaN	430.0	414.0
1002	NaN	NaN	NaN	NaN	NaN	117.0	214.0	289.0	206.0	212.0	243.0	236.0
1003	NaN	NaN	NaN	NaN	NaN	NaN	NaN	380.0	961.0	855.0	824.0	802.0
1004	NaN	NaN	NaN	NaN	35.0	171.0	135.0	137.0	117.0	145.0	117.0	130.0
Подсчёт количества сделанных звонков для каждого пользователя помесячно.
Формируем таблицу, которая показывает количество отправленных сообщений, и траффик, по месяцам и по каждому абоненту. Проверяем, что получилось.

calls_count_df_by_user_month.head()
month	1	2	3	4	5	6	7	8	9	10	11	12
user_id												
1000	NaN	NaN	NaN	NaN	17.0	28.0	41.0	42.0	46.0	44.0	37.0	38.0
1001	NaN	NaN	NaN	NaN	NaN	NaN	NaN	NaN	NaN	NaN	45.0	47.0
1002	NaN	NaN	NaN	NaN	NaN	14.0	21.0	37.0	25.0	24.0	25.0	27.0
1003	NaN	NaN	NaN	NaN	NaN	NaN	NaN	43.0	105.0	97.0	95.0	88.0
1004	NaN	NaN	NaN	NaN	7.0	25.0	20.0	18.0	18.0	21.0	15.0	15.0
Подсчёт количества отправленных сообщений каждым пользователем помесячно
Формируем таблицу, которая показывает количество смс, отправленных каждым пользователем помесячно. Смотрим что получилось.

sms_df_by_user_month = sms_df.pivot_table(index='user_id', columns='month', values='id', aggfunc='count')
sms_df_by_user_month.head(5)
month	1	2	3	4	5	6	7	8	9	10	11	12
user_id												
1000	NaN	NaN	NaN	NaN	22.0	60.0	75.0	81.0	57.0	73.0	58.0	70.0
1002	NaN	NaN	NaN	NaN	NaN	4.0	11.0	13.0	4.0	10.0	16.0	12.0
1003	NaN	NaN	NaN	NaN	NaN	NaN	NaN	37.0	91.0	83.0	94.0	75.0
1004	NaN	NaN	NaN	NaN	95.0	134.0	181.0	151.0	146.0	165.0	158.0	162.0
1005	7.0	38.0	56.0	41.0	42.0	47.0	56.0	64.0	52.0	44.0	51.0	54.0
Подсчёт израсходованного интернет-траффика по каждому пользователю помесячно
Формируем таблицу, которая показывает количество израсходованного интернет траффика помесячно, в мегабайтах.

internet_df_by_user_month = internet_df.pivot_table(index='user_id', columns='month', values = 'mb_used', aggfunc='sum')
internet_df_by_user_month.head(5)
month	1	2	3	4	5	6	7	8	9	10	11	12
user_id												
1000	NaN	NaN	NaN	NaN	2256.0	23257.0	14016.0	14070.0	14581.0	14717.0	14768.0	9827.0
1001	NaN	NaN	NaN	NaN	NaN	NaN	NaN	NaN	NaN	NaN	18452.0	14053.0
1002	NaN	NaN	NaN	NaN	NaN	10871.0	17601.0	20347.0	16712.0	13905.0	18610.0	18137.0
1003	NaN	NaN	NaN	NaN	NaN	NaN	NaN	8571.0	12479.0	14779.0	11368.0	10132.0
1004	NaN	NaN	NaN	NaN	13415.0	17619.0	22243.0	28607.0	15125.0	18494.0	15631.0	18038.0


Готовим данные для формирования сводных таблиц по потреблённым услугам.
Индексируем таблицу users_df, по полю user_id, чтобы потом объединять таблицу users_df с другими.

users_df.set_index('user_id', inplace=True)


Готовим данные для расчёта расходов на абонента
формируем таблицу, в которой будут рассчитываться доходы на абонента помесячно. Сначала выписываем, сколько минут тратил каждый пользователь в каждом месяце. Для удобства данные заносим в один столбец.

calls_df_revenue = calls_df.pivot_table(index=['user_id', 'month'], aggfunc='sum')
calls_df_revenue.head(10)
duration
user_id	month	
1000	5	159
6	172
7	340
8	408
9	466
10	350
11	338
12	333
1001	11	430
12	414
Присоединяем список пользоватлей, к помесячному списку звонков каждого пользователя.

calls_df_revenue = calls_df_revenue.join(users_df)
calls_df_revenue.head()
duration	age	churn_date	city	first_name	last_name	reg_date	tariff	mnth_reg	mnth_chrn	mnth_ttl
user_id	month											
1000	5	159	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8
6	172	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8
7	340	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8
8	408	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8
9	466	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8


tariffs_df.set_index('tariff_name', inplace=True)
calls_df_revenue = calls_df_revenue.join(tariffs_df, on='tariff')
calls_df_revenue.head(10)
duration	age	churn_date	city	first_name	last_name	reg_date	tariff	mnth_reg	mnth_chrn	mnth_ttl	messages_included	mg_per_month_included	minutes_included	rub_monthly_fee	rub_per_gb	rub_per_message	rub_per_minute
user_id	month																		
1000	5	159	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
6	172	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
7	340	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
8	408	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
9	466	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
10	350	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
11	338	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
12	333	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
1001	11	430	41	2018-12-31	Москва	Иван	Ежов	2018-11-01	smart	11	12	2	50	15360	500	550	200	3	3
12	414	41	2018-12-31	Москва	Иван	Ежов	2018-11-01	smart	11	12	2	50	15360	500	550	200	3	3
Готовим данные для расчёта расходов на абонента
Считаем ежемесячный доход в рублях на каждого пользователя помесячно. Считается только стоимость звонков, которые не покрываются абонентской платой.

def income_calls (duration, tariff, minutes_included, rub_per_minute):
    if tariff == 'ultra':
        if duration <= minutes_included:
            return 0
        else:
            return (duration - minutes_included) * rub_per_minute
    elif tariff == 'smart':
        if duration <= minutes_included:
            return 0
        else:
            return (duration - minutes_included) * rub_per_minute
    
    
    
calls_df_revenue['income_call'] = calls_df_revenue.apply(lambda x: income_calls(x['duration'], x['tariff'], x['minutes_included'], x['rub_per_minute']), axis = 1)

def income_calls (duration, minutes_included, rub_per_minute):
    if duration <= minutes_included:
        return 0
    else:
        return (duration - minutes_included) * rub_per_minute
То есть всё-таки тариф нам не нужен и мы можем не писать функцию совсем, а вместо этого использовать поколоночные операции.

Надеюсь, я смогла тебя убедить :)

P.S. И то же ниже в income_sms и income_mb1

Группируем расходы, не покрываемые абонентской платой помесячно

calls_df_revenue_month = calls_df_revenue.pivot_table(index='user_id', columns = 'month', values = 'income_call')
calls_df_revenue_month = calls_df_revenue_month.fillna(0)
calls_df_revenue_month.head()
month	1	2	3	4	5	6	7	8	9	10	11	12
user_id												
1000	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0
1001	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0
1002	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0
1003	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0
1004	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0


Считаем итог за весь период по каждому пользователю. Для хранения итога создаём отдельную таблицу.

calls_df_revenue_month['ttl_incm_clls'] = calls_df_revenue_month[[1,2,3,4,5,6,7,8,9,10,11,12]].sum(axis=1)
calls_df_revenue_total = calls_df_revenue_month['ttl_incm_clls']
Комментарий от наставника 3 итерация 2
Тогда уж давай хотя бы заменим [1,2,3,4,5,6,7,8,9,10,11,12] на list(range(1,13)) :)

И то же везде ниже.

Формируем таблицу в которой считаем количество отправленных смс по каждому пользователю помесячно.

sms_revenue = sms_df.pivot_table(index=['user_id', 'month'], values='id', aggfunc='count')
sms_revenue.head(10)
id
user_id	month	
1000	5	22
6	60
7	75
8	81
9	57
10	73
11	58
12	70
1002	6	4
7	11
Присоединяем таблицу к списку пользователей. Смотрим что получилось.

sms_revenue = sms_revenue.join(users_df)
sms_revenue.head()
id	age	churn_date	city	first_name	last_name	reg_date	tariff	mnth_reg	mnth_chrn	mnth_ttl
user_id	month											
1000	5	22	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8
6	60	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8
7	75	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8
8	81	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8
9	57	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8
Считаем доходы от отправленных смс. В доходы включаются только смс, которые не включены в тарифный план.

sms_revenue = sms_revenue.join(tariffs_df, on='tariff')
sms_revenue.head(10)
id	age	churn_date	city	first_name	last_name	reg_date	tariff	mnth_reg	mnth_chrn	mnth_ttl	messages_included	mg_per_month_included	minutes_included	rub_monthly_fee	rub_per_gb	rub_per_message	rub_per_minute
user_id	month																		
1000	5	22	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
6	60	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
7	75	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
8	81	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
9	57	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
10	73	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
11	58	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
12	70	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
1002	6	4	59	2018-12-31	Стерлитамак	Евгений	Абрамович	2018-06-17	smart	6	12	7	50	15360	500	550	200	3	3
7	11	59	2018-12-31	Стерлитамак	Евгений	Абрамович	2018-06-17	smart	6	12	7	50	15360	500	550	200	3	3
def income_sms (id_sms, tariff, messages_included, rub_per_message):
    if tariff == 'ultra':
        if id_sms <= messages_included:
            return 0
        else:
            return (id_sms - messages_included) * rub_per_message
    elif tariff == 'smart':
        if id_sms <= messages_included:
            return 0
        else:
            return (id_sms - messages_included) * rub_per_message
    
    
    
sms_revenue['income_sms'] = sms_revenue.apply(lambda x: income_sms(x['id'], x['tariff'], x['messages_included'], x['rub_per_message']), axis = 1)
Группируем доходы от смс, не вошедшие в тарифные планы, помесячно.

sms_revenue_month = sms_revenue.pivot_table(index='user_id', columns='month', values='income_sms')
sms_revenue_month = sms_revenue_month.fillna(0)
sms_revenue_month.head()
month	1	2	3	4	5	6	7	8	9	10	11	12
user_id												
1000	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0
1002	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0
1003	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0
1004	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0
1005	0.0	0.0	18.0	0.0	0.0	0.0	18.0	42.0	6.0	0.0	3.0	12.0
Считаем итоговый доход от отправленных смс, не покрытых тарифным планом, по каждому пользователю.

sms_revenue_month['ttl_incm_sms'] = sms_revenue_month[[1,2,3,4,5,6,7,8,9,10,11,12]].sum(axis=1)
sms_revenue_total = sms_revenue_month['ttl_incm_sms']
Формируем таблицу, в которой считается израсходованный трафик по каждому пользователю помесячно

internet_df_revenue = internet_df.pivot_table(index=['user_id', 'month'], values='mb_used', aggfunc='sum')
internet_df_revenue.head()
mb_used
user_id	month	
1000	5	2256
6	23257
7	14016
8	14070
9	14581
Просоединяем таблицу, к общему списку пользователей.

internet_df_revenue = internet_df_revenue.join(users_df)
Считаем доходы от интернет-траффика, сверх предусмотренных тарифными планами, по каждому пользователю. Присоединеям к таблице условия тарифов. Смотрим что получилось.

internet_df_revenue = internet_df_revenue.join(tariffs_df, on='tariff')
internet_df_revenue.head(10)
mb_used	age	churn_date	city	first_name	last_name	reg_date	tariff	mnth_reg	mnth_chrn	mnth_ttl	messages_included	mg_per_month_included	minutes_included	rub_monthly_fee	rub_per_gb	rub_per_message	rub_per_minute
user_id	month																		
1000	5	2256	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
6	23257	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
7	14016	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
8	14070	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
9	14581	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
10	14717	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
11	14768	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
12	9827	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	1000	30720	3000	1950	150	1	1
1001	11	18452	41	2018-12-31	Москва	Иван	Ежов	2018-11-01	smart	11	12	2	50	15360	500	550	200	3	3
12	14053	41	2018-12-31	Москва	Иван	Ежов	2018-11-01	smart	11	12	2	50	15360	500	550	200	3	3
def income_mb1 (mb_used, tariff, mg_per_month_included, rub_per_gb):
    if tariff == 'ultra':
        if mb_used <= mg_per_month_included:
            return 0
        else:
            gb = math.ceil((mb_used - mg_per_month_included) * 0.001)
            return gb * rub_per_gb
    elif tariff == 'smart':
        if mb_used <= mg_per_month_included:
            return 0
        else:
            gb = math.ceil((mb_used - mg_per_month_included) * 0.001)
            return gb * rub_per_gb
    
    
    
internet_df_revenue['income_mb'] = internet_df_revenue.apply(lambda x: income_mb1(x['mb_used'], x['tariff'], x['mg_per_month_included'], x['rub_per_gb']), axis = 1)


Группируем доходы от интернет-траффика, сверх предусмотренного тарифными планами по месяцам, по каждому пользователю. Смотрим что получилось.

internet_df_revenue_month = internet_df_revenue.pivot_table(index='user_id', columns='month', values='income_mb')
internet_df_revenue_month = internet_df_revenue_month.fillna(0)
internet_df_revenue_month.head()
month	1	2	3	4	5	6	7	8	9	10	11	12
user_id												
1000	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0
1001	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	800.0	0.0
1002	0.0	0.0	0.0	0.0	0.0	0.0	600.0	1000.0	400.0	0.0	800.0	600.0
1003	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0
1004	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0	0.0
Считаем общий доход за использование интернет-траффика, не включённый в тарифы. Итог включаем в отдельный столбец. Для хранения итога создаём отдельную таблицу.

internet_df_revenue_month['ttl_incm_mb'] = internet_df_revenue_month[[1,2,3,4,5,6,7,8,9,10,11,12]].sum(axis=1)
internet_revenue_total = internet_df_revenue_month['ttl_incm_mb']
Создаём таблицу, где считаются общие доходы по каждому пользователю.

main_income = users_df.join(calls_df_revenue_total)
main_income = main_income.join(sms_revenue_total)
main_income = main_income.join(internet_revenue_total)
main_income = main_income.fillna(0)
main_income.head()
age	churn_date	city	first_name	last_name	reg_date	tariff	mnth_reg	mnth_chrn	mnth_ttl	ttl_incm_clls	ttl_incm_sms	ttl_incm_mb
user_id													
1000	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	0.0	0.0	0.0
1001	41	2018-12-31	Москва	Иван	Ежов	2018-11-01	smart	11	12	2	0.0	0.0	800.0
1002	59	2018-12-31	Стерлитамак	Евгений	Абрамович	2018-06-17	smart	6	12	7	0.0	0.0	3400.0
1003	23	2018-12-31	Москва	Белла	Белякова	2018-08-17	ultra	8	12	5	0.0	0.0	0.0
1004	68	2018-12-31	Новокузнецк	Татьяна	Авдеенко	2018-05-14	ultra	5	12	8	0.0	0.0	0.0
Комментарий для наставника
Ирина, здесь чтобы убрать цифры из функции я опять присоединяю таблицу с тарифами.

Считаем общий доход от каждого пользователя, и среднемесячную выручку каждого пользователя.

tariffs_df_light = tariffs_df['rub_monthly_fee']
tariffs_df_light
tariff_name
smart     550
ultra    1950
Name: rub_monthly_fee, dtype: int64
main_income = main_income.join(tariffs_df_light, on='tariff')
def income_total (tariff, ttl_incm_clls, ttl_incm_sms, ttl_incm_mb, mnth_ttl, rub_monthly_fee):
    if tariff == 'smart':
        return mnth_ttl * rub_monthly_fee + ttl_incm_clls + ttl_incm_sms + ttl_incm_mb
    elif tariff == 'ultra':
        return mnth_ttl * rub_monthly_fee + ttl_incm_clls + ttl_incm_sms + ttl_incm_mb


main_income['incm_ttl'] = main_income.apply(lambda x: income_total(x['tariff'], x['ttl_incm_clls'], x['ttl_incm_sms'], x['ttl_incm_mb'], x['mnth_ttl'], x['rub_monthly_fee']), axis = 1)
main_income['incm_by_month'] = main_income['incm_ttl'] / main_income['mnth_ttl']
main_income.head()
age	churn_date	city	first_name	last_name	reg_date	tariff	mnth_reg	mnth_chrn	mnth_ttl	ttl_incm_clls	ttl_incm_sms	ttl_incm_mb	rub_monthly_fee	incm_ttl	incm_by_month
user_id																
1000	52	2018-12-31	Краснодар	Рафаил	Верещагин	2018-05-25	ultra	5	12	8	0.0	0.0	0.0	1950	15600.0	1950.000000
1001	41	2018-12-31	Москва	Иван	Ежов	2018-11-01	smart	11	12	2	0.0	0.0	800.0	550	1900.0	950.000000
1002	59	2018-12-31	Стерлитамак	Евгений	Абрамович	2018-06-17	smart	6	12	7	0.0	0.0	3400.0	550	7250.0	1035.714286
1003	23	2018-12-31	Москва	Белла	Белякова	2018-08-17	ultra	8	12	5	0.0	0.0	0.0	1950	9750.0	1950.000000
1004	68	2018-12-31	Новокузнецк	Татьяна	Авдеенко	2018-05-14	ultra	5	12	8	0.0	0.0	0.0	1950	15600.0	1950.000000
Поиск и удаление выбросов
Поскольку нас интересуют доходы от абонентов, то и выбросы мы смотрим по показателю - среднемесячный доход с абонента. Выбросов снизу быть не может, поскольку имеется минимальная оплата по тарифу. Ищем выбросы сверху. Из анализа графика видно, что выбросы сверху имеются. 5 абонентов имеют среднемесячную нагрузку в 3150 рублей и выше.

Из выборки в 500 абонентов, это 6 человек, или 1%. Оставляем их, поскольку 1% абонентов вполне может иметь расходы на связь вдвое выше абонентской платы.

main_income['incm_by_month'].hist()
main_income_smart = main_income.query('tariff == "smart"')
main_income_smart['incm_by_month'].hist()
<matplotlib.axes._subplots.AxesSubplot at 0x7fe0d1ef1ac8>

main_income['incm_by_month'].hist(range=(3100, 4500))
<matplotlib.axes._subplots.AxesSubplot at 0x7fe0d1ea13c8>

Общее поведение клиентов на тарифах smart и ultra
Поведение большей части клиентов, за весь наблюдаемый период достаточно рационально. На графике видно, что большинство клиентов пользуются тарифами smart и ultra, при этом укладываясь в указанные тарифы. При этом, часть клиентов не укладывается в лимиты, и превышает как лимиты по тарифы smart, так и лимиты по тарифу ultrа, а около 40 из 500 клиентов выбрали невыгодный для себя тариф smart, вместо тарифа ultra.

Перевод клиентов на тариф ultra, позволит сдвинуть график доходности "вправо". При этом, за счёт клиентов, ведущие себя нерационально, этот перевод не резко усиливает доходность

Распределение поведения клиентов по месяцам, будет исследованно ниже.

Описание поведения клиентов
Пишем функцию, которая считает среднее значение, дисперсию и стандартное отклонение, а также распределение данных по квантилям (функция describe)

def describe_func (df_month, tariff1, hd_name):
    df_month_tariff = df_month[(df_month['tariff'] == tariff1)]
    mean1 = df_month_tariff[hd_name].mean()
    std1 = np.std(df_month_tariff[hd_name])
    low_limit = mean1 - 3 * std1
    high_limit = mean1 + 3 * std1
    if low_limit <= df_month_tariff[hd_name].min():
        low_limit = df_month_tariff[hd_name].min()
    if high_limit >= df_month_tariff[hd_name].max():
        high_limit = df_month_tariff[hd_name].max()
    print("Среднее значение по тарифу", tariff1, mean1)
    print("Дисперсия по тарифу", tariff1, np.var(df_month_tariff[hd_name]))
    print("Станадртное отклонение по тарифу", tariff1, std1)
    print("Тариф", tariff1, "Максимум", df_month_tariff[hd_name].max(),"Минимум:", df_month_tariff[hd_name].min())
    print("Тариф", tariff1, "Границы нормы от", low_limit, "до:", high_limit)
    print(df_month_tariff[hd_name].hist())
    return tariff1, df_month_tariff[hd_name].describe()


Описание поведения клиентов
Смотрим на распределения по количеству минут разговора у клиентов разных тарифов

describe_func(calls_df_revenue, 'smart', 'duration')
Среднее значение по тарифу smart 419.4403421882035
Дисперсия по тарифу smart 35702.04653099502
Станадртное отклонение по тарифу smart 188.9498518946099
Тариф smart Максимум 1435 Минимум: 2
Тариф smart Границы нормы от 2 до: 986.2898978720332
AxesSubplot(0.125,0.125;0.775x0.755)
('smart', count    2221.000000
 mean      419.440342
 std       188.992403
 min         2.000000
 25%       285.000000
 50%       423.000000
 75%       546.000000
 max      1435.000000
 Name: duration, dtype: float64)

Вывод по минутам разговора, которые тратят пользователи тарифа smart
Пользователи тарифа smart, часто выходят за пределы, определённые тарифом, (25% значений превышает 546 минут) при этом, для большинства пользователей, количества минут в месяц хватает (медиана месячного разговора составляет 423 минуты).

Разница между средним и медианным значением минимальна, (419 и 423 минуты), при этом минимальные и максимальные значения крайне велики, и значение нормы, рассчитанное как +- три стандартных отклонения от среднего, также очень широки (от 2 до 986 минут).

describe_func(calls_df_revenue, 'ultra', 'duration')
Среднее значение по тарифу ultra 547.7550158394931
Дисперсия по тарифу ultra 93239.86606512647
Станадртное отклонение по тарифу ultra 305.35203628783364
Тариф ultra Максимум 1673 Минимум: 1
Тариф ultra Границы нормы от 1 до: 1463.811124702994
AxesSubplot(0.125,0.125;0.775x0.755)
('ultra', count     947.000000
 mean      547.755016
 std       305.513385
 min         1.000000
 25%       311.000000
 50%       529.000000
 75%       758.000000
 max      1673.000000
 Name: duration, dtype: float64)

Вывод по минутам разговора, которые тратят пользователи тарифа ultra
Пользователи тарифа ultra, говорят чуть больше чем пользователи тарифа smart. До определённого тарифом предела в 3000 минут, ни один абонент не подошёл даже близко.

Средние и медианные значения также досточно близки (548 и 529 минут), и вполне соответствуют тарифу smart. Границы нормы также очень широки от одной минуты до 1464 минут.

describe_func(sms_revenue, 'smart', 'id')
Среднее значение по тарифу smart 38.71644120707596
Дисперсия по тарифу smart 717.220843110227
Станадртное отклонение по тарифу smart 26.780979129042816
Тариф smart Максимум 143 Минимум: 1
Тариф smart Границы нормы от 1 до: 119.0593785942044
AxesSubplot(0.125,0.125;0.775x0.755)
('smart', count    1922.000000
 mean       38.716441
 std        26.787949
 min         1.000000
 25%        17.000000
 50%        34.000000
 75%        55.000000
 max       143.000000
 Name: id, dtype: float64)

Вывод по количеству смс, которые тратят пользователи тарифа smart
Большая часть пользователей ежемесячно укладывается в лимит, определённый тарифом smart. При этом, часть пользователей или почти не использует смс, или пишет очень много смс, о чём говорят границы нормы (от 1 до 119 смс).

Среднее и медианное значение отличаются не сильно (39 и 34 смс).

describe_func(sms_revenue, 'ultra', 'id')
Среднее значение по тарифу ultra 61.161006289308176
Дисперсия по тарифу ultra 2107.0055235156838
Станадртное отклонение по тарифу ultra 45.90212983637779
Тариф ultra Максимум 224 Минимум: 1
Тариф ultra Границы нормы от 1 до: 198.86739579844155
AxesSubplot(0.125,0.125;0.775x0.755)
('ultra', count    795.000000
 mean      61.161006
 std       45.931026
 min        1.000000
 25%       24.000000
 50%       51.000000
 75%       87.500000
 max      224.000000
 Name: id, dtype: float64)

Вывод по количеству смс, которые тратят пользователи тарифа ultra
Пользователи тарифа ultra, также близко не используют необходимого лимита по услугам. Максимальное количество сообщений - 224. Границы нормы - 199. При этом, как и для минут разговора, среднее и медианное значение (61 и 51), больше соответствуют тарифу smart.

describe_func(internet_df_revenue, 'smart', 'mb_used')
Среднее значение по тарифу smart 16243.763358778626
Дисперсия по тарифу smart 34324671.66515046
Станадртное отклонение по тарифу smart 5858.726112829517
Тариф smart Максимум 38610 Минимум: 202
Тариф smart Границы нормы от 202 до: 33819.941697267175
AxesSubplot(0.125,0.125;0.775x0.755)
('smart', count     2227.000000
 mean     16243.763359
 std       5860.041941
 min        202.000000
 25%      12677.000000
 50%      16533.000000
 75%      20068.000000
 max      38610.000000
 Name: mb_used, dtype: float64)

Вывод по траффику, которые тратят пользователи тарифа smart
Пользователи, в осносном несколько превышают лимиты интернет-траффика, установленные тарифом. Как в потреблении минут и смс, имеются люди не пользующиеся интернетом, так и люди тратящие более 30 ГБ траффика.

Среднее и медианное значение одинаковы (16244 и 16533 мегабайт). При этом 50% пользователей используют от 12677 до 20068 мегабайт трафика в месяц. Границы нормы (среднее значение +- три отклонения) составляют от 202 до 33820 мегабайт.

Поведение большинства абонентов в принципе рационально. При этом, часть абонентов не переходя на более дорогой (и выгодный для них) тариф ultra, позволяет генерировать высокую прибыль.

describe_func(internet_df_revenue, 'ultra', 'mb_used')
Среднее значение по тарифу ultra 19706.979466119097
Дисперсия по тарифу ultra 98645116.49033812
Станадртное отклонение по тарифу ultra 9932.024793079108
Тариф ultra Максимум 49789 Минимум: 366
Тариф ultra Границы нормы от 366 до: 49503.05384535642
AxesSubplot(0.125,0.125;0.775x0.755)
('ultra', count      974.000000
 mean     19706.979466
 std       9937.127298
 min        366.000000
 25%      12073.750000
 50%      19427.500000
 75%      26936.250000
 max      49789.000000
 Name: mb_used, dtype: float64)

Вывод по траффику, которые тратят пользователи тарифа ultra
Если, пользователи тарифа smart обычно превышают лимиты, то пользователи тарифа ultra лимиты, в основном не превышают. При этом, достаточно серьёзная часть пользователей тратит меньше 15 ГБ интернета в месяц, и для них тариф smart был бы более выгодным.

Разницы между средним и медианным значениями также нет (19707 и 19428 мегабайта). 50% пользователей используют от 12074 до 26936 мегабайт траффика. Границы нормы составляют от 366 до 49503 мегабайта траффика в месяц.

Общий вывод по поведению клиентов операторов
Тариф ultra, более выгоден оператору, поскольку абоненты платят почти в четыре раза больше, а потребляют услуг не принципиально больше чем абоненты тарифа smart. Больше услуг потребляется только в части мобильного интернета. Лимиты установленные тарифом ultra по мобильному интернету могут быть сдвинуты до 40 ГБ, этого хватит почти всем пользователям. Лимиты по звонкам и смс вполне достаточны. Лимиты, установленные тарифом smart, являются достаточными для большинства абонентов по минутам разговоров и смс. Для интернет-траффика лимиты являются недостаточными. Чтобы абоненты укладывались в лимит, нужно предоставить 23 ГБ интернет-траффика.

Часть абонентов использует очень незначительное количество минут/смс/трафика.


Проверяем гипотезу по выручке пользователей разных тарифов ✓
Генеральными совокупностями являются - все (а не только те, что представлены в исследуемых данных) пользователи тарифов smart и ultra, соответственно. Соответственно, нулевая гипотеза звучит так:

Среднемесячная выручка всех абонентов тарифа smart, равна среднемесячной выручке всех абонентов тарифа ultra. А альтернативная гипотеза так:

Среднемесячная выручка всех абонентов тарифа smart, отличается от среднемесячной выручки абонентов тарифа ultra.

Для проверки используется метод - scipy.stats.ttest_ind(). Для проверки сравним выборки по тарифу smart и тарифу ultra. Поскольку выборки отбирались из схождих по параметрам совокупностей (случайный набор абонентов), то дисперсию выборки считаем равной.

Пороговое значение, устанавливаем в размере 0.05.


main_income_ultra = main_income.query('tariff == "ultra"')
mean_ultra = main_income_ultra['incm_by_month']
main_income_smart = main_income.query('tariff == "smart"')
mean_smart = main_income_smart['incm_by_month']
results = st.ttest_ind(
    mean_ultra,
    mean_smart
)
print(results.pvalue)
1.5471557361508935e-38
Поскольку значение pvalue, для выборок по тарифам smart и ultra является крайне низкой, то гипотеза о том, что выручка пользователей тарифа smart равна выручке пользователей тарифа ultra опровергнута.

Проверяем гипотезу по выручке пользователей в Москве и других регионах. Генеральными совокупностями являются - все (а не только те, что представлены в исследуемых данных) абоненты из города Москва и абоненты из других регионгов, соответственно. Соответственно, нулевая гипотеза звучит так:

Среднемесячная выручка абонентов из Москвы равна среднемесячной выручке пользоватлей из других регионов.

А альтернативная гипотеза так:

Среднемесячная выручка абонентов из Москвы отличается от среднемесячной выручки пользователей из других регионов.

Для проверки используется метод - scipy.stats.ttest_ind(). Для проверки сравним выборки по абонентам из Москвы и иных регионов. Поскольку выборки отбирались из схождих по параметрам совокупностей (случайный набор абонентов), то дисперсию выборки считаем равной.

Пороговое значение, устанавливаем в размере 0.05.

Проверяем гипотезу по выручке пользователей Москвы и иных регионов ✓
Считаем среднюю выручку пользователей из Москвы. Затем берём список пользователей не из Москвы, и считаем вероятность того, что выручка пользователей из Москвы будет равна выручке пользователей из других регионов. Проверяем методом - st.ttest_1samp.

main_income_moscow = main_income.query('city == "Москва"')
mean_moscow = main_income_moscow['incm_by_month']
main_income_regions = main_income.query('city != "Москва"')
mean_regions = main_income_regions['incm_by_month']
results = st.ttest_ind(
    mean_moscow,
    mean_regions
)
print(results.pvalue)
0.3733884964511449
Поскольку значение pvalue, для выборок по абонентам, живущим в Москве и иных регионах является крайне достаточно высоким (0.37), то гипотеза о том, что выручка пользователей из Москвы равна выручке пользователей из регионов не опровергнута.


Общий вывод: ✓
После анализа установлено, что оператору более выгоден тариф ultra, но с оговорками:

часть пользователей (около 10%) действуют нерационально, применяя невыгодный для себя (и выгодный для оператора), тариф "смарт".
части пользователей тариф ultra заведомо не подходит.
Поведение большей части пользователей рационально, они не выходят за установленные тарифами лимиты.

Пользователям хватает предоставленных минут разговора и смс, и не хватает предоставленного в рамках тарифных планов траффика. Соответственно, если нужно повышать лояльность, нужно повышать лимиты траффика.

Значительное количество пользователей даже близко не используют предоставленные объёмы траффика, минут и смс.

Выручка пользователей тарифа смарт, меньше чем у пользователей тарифа ультра. Выручка пользователей из Москвы, примерно совпадает с выручкой пользователей регионов.

Финальный комментарий от наставника
Спасибо за исправления, теперь стало существенно лучше!

Остались некритичные замечания, просто постарайся их учесть в сборном проекте. Удачи! :)

Работа засчитана.
